# 백준 1463번 - 1로 만들기
## 문제 
* 문제 링크 : https://www.acmicpc.net/problem/1463
* 문제 해석
    * 정수 N을 입력받아 3가지 연산을 이용해 최소의 연산 횟수로 1을 만들어야 함

## 풀이 
* 그리디 방법을 이용하기에는 현재 3으로 나누는게 최선이라도 이로 인해 그 다음에 해야할 연산이 늘어날 수 있음
* 같은 과정 반복하는 재귀적인 구조 문제에서 알 수 있었음
* 따라서, 부분 문제로 나누어 점화식 만들어 재귀적인 구조를 활용해 하나의 문제를 푸는 동적 계획법으로 접근한다
* 배열 arr를 정의하는데 arr[k]는 k를 1을 만들기 위해 사용한 연산 횟수의 최솟값이다
* arr[1], arr[2], arr[3]은 기본값으로 1을 갖는다
* 연산에 따라 점화식 세우면 
    * 3으로 나누어 떨어질 경우 arr[i]=arr[i/3]+1
    * 2로 나누어 떨어질 경우 arr[i]=arr[i/2]+1
    * 1을 빼는 연산한 경우 arr[i]=arr[i-1]+1
* 1을 빼는 연산은 현재 값이 1이 아닌 경우에는 항상 가능하므로 기본 값으로 대입한 후 3, 2로 나누어 떨어지는 여부에 따라 최솟 값을 구한다
* 일부 코드
```
	arr[i]=arr[i-1]+1;
	if(i%3==0) arr[i]=min(arr[i],arr[i/3]+1);
	if(i%2==0) arr[i]=min(arr[i],arr[i/2]+1);
```
* 이 점화식을 이용해 bottom-up 방식으로 정답 구한다
* 3이나 2
* 전체 코드)
```
#include<iostream>
#include<algorithm>
using namespace std;
int main(){//dp 
	int arr[1000001]; // 배열 크기 조건 잘보기 
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		arr[i]=99999;
	}
	arr[1]=0;
	arr[2]=arr[3]=1;
	for(int i=4;i<=n;i++){ 
		arr[i]=arr[i-1]+1;
		if(i%3==0) arr[i]=min(arr[i],arr[i/3]+1);
		if(i%2==0) arr[i]=min(arr[i],arr[i/2]+1);
	}
	cout<<arr[n]<<"\n";
}
```
* 리뷰 
    * 처음에는 그리디로 풀어보려 했으나 적합하지 않음 깨달음
    * 처음 문제 부분문제로 나누어 품-> dp로 접근
    * if문을 통해 모든 경우를 분리하여 그에 따른 최솟값 구하려 함 
    * if문이 너무 많아 처음에 초기화 1을 빼는 연산으로 넣어놓는 과정 넣어 if문 줄임
    